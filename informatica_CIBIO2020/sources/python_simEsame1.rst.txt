=========================
Python: Simulazione esame
=========================

Proviamo a simulare insieme una prova d'esame! in particolare stiamo simulando l'esame del 24 7 2020


TESTO
-----
Scrivere un programma che  
  

#. prenda in ingresso:
    #. un file con annotazioni di score di artefatti in ecografie polmonari, fatte da più medici diversi. 
    #. due indici di medici di cui confrontare le annotazioni

#. per ogni coppia di score s i , s j stampi il numero di volte in cui il primo medico ha annotato un’ecografica come s i ed il secondo come s j (anche quando s i = s j )
#. stampi il numero totale di volte in cui i due medici sono stati d’accordo, ed il numero di volte in cui sono stati in disaccordo


**ESMPIO File in input**

video_scores.csv::

    Video	Score M1	Score M2	Score M3	Score M4	Score M5	Score M6
    1	2	1	2	3	3	2	
    2	1	2	1	1	1	2	
    3	3	3	3	3	3	1	
    4	3	3	3	3	3	3


**ESMPIO DI OUTPUT**

python agreement.py::

    Inserire nome file: video_scores.csv
    Indice primo medico: 0
    Indice secondo medico: 4
    M0  M4  Count
    2   3   8
    1   1   5
    3   3   5
    0   0   11
    0   1   6
    Totale accordo: 28
    Totale disaccordo: 32


**SUGGERIMENTI**

Si possono implementare 5 funzioni separate:


#. una che legga il file dati e restituisca una lista di liste di score (una per ogni video)
#. una che data la lista di liste ed un indice, restituisca la lista di score associati al medico con quell’indice
#. una che data la lista di liste e due indici, restituisca un dizionario che per ogni coppia di score (s i , s j ) contiene il numero di volte in cui il primo medico ha annotato con s i e il secondo con s j
#. una che dato il dizonario (e gli indici dei medici per l’intestazione) stampi i conteggi delle varie coppie di score e calcoli e stampi i totali di accordo e disaccordo
#. una (o un main) che realizzi il programma richiesto usando le funzioni di cui sopra


Soluzione
---------

**LEGGETE E RI LEGGETE la consegna per capire se è chiara**

iniziamo seguendo i suggerimenti:

suggerimento 1
    #. una che legga il file dati e restituisca una **lista di liste** di score (una per ogni video)

**SEMPLICE**
lo abbiamo sempre fatto::

    def load_file(filename):   #definisco la funzione

        file = open(filename,"r") #apro il file in modalità read
        righe = file.readlines()  #leggo le tighe
        res = []                  #creo una variabile contenente il risultato
        
        for i in righe[1:]:       # itero sulle righe saltando la prima 
                                  # perche è un intestazione 
            res.append(i.split()[1:])   # splitto la riga, e prendo tutti gli elementi
                                        # eccetto il primo, perche è il numero del video


**E' corretto il codice che abbiamo scritto fino ad ora?**
non lo so, ma posso verificarlo::

    prova = load_file(filename)
    print(prova)


si, funziona!

suggerimento 2
    #. una che data la lista di liste ed un indice, restituisca la lista di score associati al medico con quell’indice

mmmm, che cosa ci sta chiedendo?  
ci chiede di creare una funzione che prenda in input la lista di liste (il file che abbiamo appena caricato con load_file), 
e un indice (riferito ad un medico), ci restituisca una **lista** contenente gli score che ha dato il medico.
Quindi, se come indice abbiamo inserito 1, allora il la nostra funzione deve restituire la lista [2,1,3,3,...]

**SEMPLICE**::

    def get_score(table,index):
        scores = []
        for row in table:               #itero sulla ogni riga della tabella
            scores.append(row[index])   #mi salvo solo i valori in posizione index
        return(scores)


**E' corretto il codice che abbiamo scritto fino ad ora?**
non lo so, ma posso verificarlo::

    prova = load_file(filename)
    scores = get_score(prova,index)
    print(scores)


si, funziona!

suggerimento 3
    #. una che data la lista di liste e due indici, restituisca un dizionario che per ogni coppia di score (s i , s j ) contiene il numero di volte in cui il primo medico ha annotato con s i e il secondo con s j

mmmm, che cosa ci sta chiedendo? 
ci chiede di creare una funzione che prenda in input la lista di liste (il file che abbiamo appena caricato con load_file), 
e *due* indici (riferiti a due medici), ci restituisca un **dizionario**. Il dizionario deve aver come chiave la coppia degli score data dai medici, e come valore il totale delle volte in cui si è verificata questa situazione.
Esempio, supponiamo che le liste degli scores dei medici m1 e m2 siano le seguenti::

    Score M1 = [2,1,3,3]
    Score M2 = [1,2,3,3]

allora il dizionario in output è il seguente::

    diz = { 
        (2,1): 1,
        (1,2): 1,
        (3,3): 3,
        }

Ora che abbiamo capito la consegna, scrivere il codice è easy :) ::

    def get_agreement(table,m1,m2):
        score_m1 = get_score(table,m1)  #uso la funzione che ho fatto prima per prendere gli score del medico m1
        score_m2 = get_score(table,m2)  #uso la funzione che ho fatto prima per prendere gli score del medico m2

        diz = dict()
        for i in range(len(score_m1)):       #itero sul range della lungheza degli score i.e il numero di video

            key = (score_m1[i],score_m2[i])  # creo la chiave, che è una coppia di score (score di m1, score di m2)
            if key in diz:                   # se la chiave è già presente nel dizionario, allora incremento il suo valore
                diz[key] = diz[key] + 1
            else:                            # altrimenti (se non è presente)
                diz[key] = 1                 # aggiungo la chiave al dizionario con valore 1

        return(diz)



**E' corretto il codice che abbiamo scritto fino ad ora?**
non lo so, ma posso verificarlo::

    prova = load_file(filename)
    dizionario = get_agreement(prova,m1,m2)
    print(dizionario)


si, funziona!



suggerimento 4

#. una che dato il dizonario (e gli indici dei medici per l’intestazione) stampi i conteggi delle varie coppie di score e calcoli e stampi i totali di accordo e disaccordo

In sostanza qui ci sta chiedendo di stampare l'output in un formato piu leggibile (come quelle del esempio del output), 
e ci sta anche chiedendo di calcolare il numero di volte in cui i medici sono in accordo e quelle in cui sono in disaccordo.

semplice::

    def print_agreemnt(diz,m1,m2):
        tot_agree = 0                       #inizializzo gli agree
        tot_disagree = 0                    #inizializzo i  disagree
        print("M%d\tM%d\tCount" %(m1,m2))   #stampo un intestazione 
        for i,j in diz.keys():              #itero sulle chiavi del dizionario
            print(i,"\t",j,"\t",diz[(i,j)]) #stampo score di m1, score di m2, e valore
            if i == j:                      # se sono in accordo
                tot_agree = tot_agree + diz[(i,j)]  # incremento il tot_agree
            else:                                         # se non sono in accordo
                tot_disagree = tot_disagree + diz[(i,j)]  # incremento il tot_disagree
                
        print("Totale accordo: ",tot_agree)
        print("Totale disaccordo: ",tot_disagree)



suggerimento 5

#. una (o un main) che realizzi il programma richiesto usando le funzioni di cui sopra

semplice ci chiede di mettere tutto insieme::

    def load_file(filename):

        file = open(filename,"r")
        righe = file.readlines()
        res = []
        for i in righe[1:]:
            res.append(i.split()[1:])

        return(res)

    def get_score(table,index):
        scores = []
        for row in table:
            scores.append(row[index])

        return(scores)

    def get_agreement(table,m1,m2):
        score_m1 = get_score(table,m1)
        score_m2 = get_score(table,m2)

        diz = dict()
        for i in range(len(score_m1)):
            key = (score_m1[i],score_m2[i])

            if key in diz:
                diz[key] = diz[key] + 1
            else:
                diz[key] = 1

        return(diz)



    def print_agreemnt(diz,m1,m2):
        tot_agree = 0
        tot_disagree = 0
        print("M%d\tM%d\tCount" %(m1,m2))
        for i,j in diz.keys():
            print(i,"\t",j,"\t",diz[(i,j)])
            
            if i == j:
                tot_agree = tot_agree + diz[(i,j)]
            else:
                tot_disagree = tot_disagree + diz[(i,j)]
                
        print("Totale accordo: ",tot_agree)
        print("Totale disaccordo: ",tot_disagree)




    filename = input("Inserire nome file")
    m1 = int(input("indice medico 1: "))
    m2 = int(input("indice medico 2: "))


    res = load_file(filename)
    agreement = get_agreement(res,m1,m2)
    print_agreemnt(agreement,m1,m2)



Funzioni (Soluzioni)
-------------------

#. Soluzione: lo stesso tipo del valore che gli passo! La funzione restituisce
   il valore dell'argomento senza toccarlo.

   #. un intero.
   #. un dizionario.
   #. una lista.
   #. un razionale.

#. Soluzione: la somma o concatenazione dei due argomenti. Quindi:

   #. un intero.
   #. una lista.
   #. una stringa.

#. Soluzione::

    def stampa_pari_dispari(numero):
        if numero % 2 == 0:
            print("pari")
        else:
            print("dispari")

    stampa_pari_dispari(98)
    stampa_pari_dispari(99)

   Occhio che ``stampa_pari_dispari()`` stampa gia' da se' a schermo,
   non e' necessario fare::

    print(stampa_pari_dispari(99))

   altrimenti Python stampera'::

    pari
    None

   Il ``None`` viene dal ``print`` aggiuntivo: visto che ``stampa_pari_dispari()``
   non ha ``return``, il suo risultato e' sempre ``None``. Il ``print`` aggiuntivo
   stampa proprio questo ``None``.

#. Soluzione::

    def calcola_pari_dispari(numero):
        if numero % 2 == 0:
            return "pari"
        else:
            return "dispari"

    print(calcola_pari_dispari(98))
    print(calcola_pari_dispari(99))

   In questo caso invece, visto che non c'e' nessun ``print`` in ``calcola_pari_dispari()``,
   e' necessario aggiungere a mano un ``print`` che ne stampi il risultato!

#. Soluzione::

    def controlla_alfanumerico(stringa):
        caratteri_alfanumerici = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"

        alfanumerica = True
        for carattere in stringa:
            if not carattere in caratteri_alfanumerici:
                alfanumerica = False

        return alfanumerica

    # testo la funzione
    print(controlla_alfanumerico("ABC123"))
    print(controlla_alfanumerico("A!%$*@"))

   Posso anche usare ``break`` per interrompere il ciclo ``for`` appena trovo
   un carattere alfanumerico (e' impossibile che una stringa dove ho appena
   trovato un carattere non-alfanumerico ridiventi alfanumerica), cosi'::

    def controlla_alfanumerico(stringa):
        caratteri_alfanumerici = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"

        alfanumerica = True
        for carattere in stringa:
            if not carattere in caratteri_alfanumerici:
                alfanumerica = False
                break # <-- esco dal for

        # <-- il break mi fa arrivare qui
        return alfanumerica

    # testo la funzione
    print(controlla_alfanumerico("ABC123"))
    print(controlla_alfanumerico("A!%$*@"))

   In alternativa, visto che quando faccio ``break`` arrivo direttamente al
   ``return``, posso saltare un passaggio e fare direttamente ``return``::

    def controlla_alfanumerico(stringa):
        caratteri_alfanumerici = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"

        for carattere in stringa:
            if not carattere.upper() in caratteri_alfanumerici:
                # ho incontrato un carattere non alfanumerico
                # posso rispondere False
                return False

        # arrivo alla fine del for solo se non ho mai fatto `return`, il
        # che succede solo se la condizione dell'`if` e' sempre stata False
        # per tutti i caratteri: vuol dire che sono tutti caratteri alfanumerici
        # rispondo True
        return True

    # testo la funzione
    print(controlla_alfanumerico("ABC123"))
    print(controlla_alfanumerico("A!%$*@"))

#. Soluzione::

    def domanda():
        percorso = input("scrivi un percorso: ")
        print(open(percorso).readlines())

    # la testo
    domanda()

#. Soluzione::

    def wc(stringa):
        num_caratteri = len(stringa)
        num_a_capo = stringa.count("\n")
        num_parole = len(stringa.split()) # split rompe sia sugli spazi che sugli a-capo
        return (num_caratteri, num_a_capo, num_parole)

    # la testo
    print(wc("sono\nuna bella\nstringa"))

#. Soluzione::

    def stampa_dizionario(un_dizionario):
        # l'ordine in cui vanno stampate le righe non importa, percio'
        # posso usare l'ordine naturale in cui mi vengono fornite da
        # `items()`
        for chiave, valore in un_dizionario.items():
            print(chiave, "->", (str(valore * 100.0) + "%"))

    # la testo

    dizionario = {
        "arginina": 0.7,
        "lisina": 0.1,
        "cisteina": 0.1,
        "istidina": 0.1,
    }

    stampa_dizionario(dizionario)

#. Soluzione::

    def stampa_dizionario_ordinato(un_dizionario):
        # estraggo le chiavi e le ordino
        chiavi_ordinate = list(un_dizionario.keys())
        chiavi_ordinate.sort()

        # ora stampo le coppie chiave-valore in ordine
        for chiave in chiavi_ordinate:
            valore = un_dizionario[chiave]

            print(chiave, "->", (str(valore * 100.0) + "%"))

    # la testo

    dizionario = {
        "arginina": 0.7,
        "lisina": 0.1,
        "cisteina": 0.1,
        "istidina": 0.1,
    }

    stampa_dizionario_ordinato(dizionario)

#. Soluzione::

    # presa dall'esempio
    def calcola_fattoriale(n):
        fattoriale = 1
        for k in range(1, n+1):
            fattoriale = fattoriale * k
        return fattoriale

    def crea_lista_di_fattoriali(n):
        lista_di_fattoriali = []
        for i in range(n):
            lista_di_fattoriali.append(calcola_fattoriale(i))
        return lista_di_fattoriali

    # la testo
    print(crea_lista_di_fattoriali(2))
    print(crea_lista_di_fattoriali(4))
    print(crea_lista_di_fattoriali(6))

   qui ho *riutilizzato* la funzione ``calcola_fattoriale()`` definita in uno
   degli esempi.

#. Soluzione::

    def conta_carattere(testo, carattere_voluto):
        conta = 0
        for carattere in testo:
            if carattere == carattere_voluto:
                conta += 1
        return conta

    # la testo
    print(conta_carattere("abbaa", "a"))
    print(conta_carattere("abbaa", "b"))
    print(conta_carattere("abbaa", "?"))

   oppure, piu' semplicemente, posso sfruttare ``count()``::

    def conta_carattere(testo, carattere_voluto):
        return testo.count(carattere_voluto)

    # la testo
    print(conta_carattere("abbaa", "a"))
    print(conta_carattere("abbaa", "b"))
    print(conta_carattere("abbaa", "?"))

#. Soluzione::

    def conta_caratteri(testo, caratteri_voluti):
        conta = {}
        for carattere_voluto in caratteri_voluti:
            conta[carattere_voluto] = conta_carattere(testo, carattere_voluto)
        return conta

    # la testo
    print(conta_caratteri("abbaa", "ab?"))

   dove ho riutilizzato la funzione dell'esercizio precedente.

#. Soluzione::

    def distanza(coppia1, coppia2):
        x1, y1 = coppia1
        x2, y2 = coppia2

        dx = x1 - x2
        dy = y1 - y2

        return (float(dx)**2 + float(dy)**2)**0.5

    # la testo
    print(distanza((0, 0), (1, 1)))
    print(distanza((2, 3), (3, 2)))

#. Soluzione::

    def sottostringa(prima, seconda):
        return seconda in prima

    # la testo
    print(sottostringa("ACGT", "T"))
    print(sottostringa("ACGT", "x"))

#. Soluzione::

    def sottostringhe_non_vuote(stringa):
        sottostringhe = []

        # tutte le possibili posizioni in cui far iniziare la sottostringa
        for inizio in range(len(stringa)):

            # tutte le poss. posizioni in cui far finire la sottostringa
            for fine in range(inizio + 1, len(stringa) + 1):

                # estraggo la sottostringa ed aggiorno la lista
                sottostringhe.append(stringa[inizio:fine])
        return sottostringhe

    # la testo
    print(sottostringhe_non_vuote("ACTG"))

#. Soluzione::

    def conta_sottostringhe(pagliaio, ago):
        ripetizioni = 0
        for inizio in range(len(pagliaio)):
            for fine in range(inizio+1, len(pagliaio)+1):

                # stampo quanto vale la sottostringa, per sicurezza
                print(inizio, fine, ":", pagliaio[inizio:fine], "==", ago, "?")

                # controllo se la sottostringa e' uguale ad `ago`
                if pagliaio[inizio:fine] == ago:
                    print("ho trovato una ripetizione!")
                    ripetizioni += 1

        return ripetizioni

    # la testo
    print(conta_sottostringhe("ACTGXACTG", "ACTG"))

#. Soluzione::

    def sottostringa_piu_lunga(stringa1, stringa2):

        # riutilizzo la soluzione sopra
        sottostringhe1 = sottostringhe_non_vuote(stringa1)
        sottostringhe2 = sottostringhe_non_vuote(stringa2)

        # controllo tra tutte le coppie di sottostringhe
        # quale e' quella piu' lunga che appare sia in
        # stringa1 che in stringa2
        piu_lunga = ""
        for sottostringa1 in sottostringhe1:
            for sottostringa2 in sottostringhe2:

                # se sono uguali e piu' lunghe della sottostringa
                # comune piu' lunga trovata fin'ora...
                if sottostringa1 == sottostringa2 and \
                   len(sottostringa1) > len(piu_lunga):

                    # aggiorno
                    piu_lunga = sottostringa1

        return piu_lunga

    # la testo
    print(sottostringa_piu_lunga("ACTG", "GCTA"))
    print(sottostringa_piu_lunga("", "ACTG"))
    print(sottostringa_piu_lunga("ACTG", ""))
